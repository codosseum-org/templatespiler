{- HLINT ignore -}
{- FOURMOLU_DISABLE -}
-- File generated by the BNF Converter (bnfc 2.9.4.1).

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language templatespiler.

module Language.Templatespiler.Abs where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

import qualified Data.Text
import qualified Data.Data    as C (Data, Typeable)
import qualified GHC.Generics as C (Generic)

type Type = Type' BNFC'Position
data Type' a
    = IntegerType a
    | StringType a
    | FloatType a
    | CombinatorType a (Combinator' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Binding = Binding' BNFC'Position
data Binding' a = Binding a Ident (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BindingGroup = BindingGroup' BNFC'Position
data BindingGroup' a = BindingGroup a [Binding' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BindingOrCombinator = BindingOrCombinator' BNFC'Position
data BindingOrCombinator' a
    = NamedBinding a (Binding' a)
    | GroupBinding a (BindingGroup' a)
    | ParenBinding a (Binding' a)
    | UnnamedBinding a (Combinator' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type Combinator = Combinator' BNFC'Position
data Combinator' a
    = ParenCombinator a (Combinator' a)
    | ArrayCombinator a (VarOrConstInt' a) (BindingOrCombinator' a)
    | SepByCombinator a String (BindingGroup' a)
    | ListCombinator a (BindingOrCombinator' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type VarOrConstInt = VarOrConstInt' BNFC'Position
data VarOrConstInt' a = ConstInt a Integer | ConstVar a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

type BindingList = BindingList' BNFC'Position
data BindingList' a = BindingList a [Binding' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable, C.Data, C.Typeable, C.Generic)

newtype Ident = Ident Data.Text.Text
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Data, C.Typeable, C.Generic, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Type where
  hasPosition = \case
    IntegerType p -> p
    StringType p -> p
    FloatType p -> p
    CombinatorType p _ -> p

instance HasPosition Binding where
  hasPosition = \case
    Binding p _ _ -> p

instance HasPosition BindingGroup where
  hasPosition = \case
    BindingGroup p _ -> p

instance HasPosition BindingOrCombinator where
  hasPosition = \case
    NamedBinding p _ -> p
    GroupBinding p _ -> p
    ParenBinding p _ -> p
    UnnamedBinding p _ -> p

instance HasPosition Combinator where
  hasPosition = \case
    ParenCombinator p _ -> p
    ArrayCombinator p _ _ -> p
    SepByCombinator p _ _ -> p
    ListCombinator p _ -> p

instance HasPosition VarOrConstInt where
  hasPosition = \case
    ConstInt p _ -> p
    ConstVar p _ -> p

instance HasPosition BindingList where
  hasPosition = \case
    BindingList p _ -> p

